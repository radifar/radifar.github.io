[{"content":"What is a Domain-Specific Language? It is more common than you think. Few of us – computational chemists – have heard the term Domain-Specific Language (DSL for short), even though this is somewhat ubiquitous in our workflow, especially when dealing with molecule visualisation. Don\u0026rsquo;t you believe me? Check out the command you type on VMD, PyMOL, YASARA, or Chimera.\nYASARA command:\nLoadPDB 1crn, download=yes AutoPosOriObj 1, x = 1, y = 10, z = 0, alpha = 0, beta = 0, gamma = 0 ColorRes cys, green ShowRes cys BallStickRes cys AutoRotateObj 1, Y = 1 wait 180 AutoRotateObj 1, Y = 0 ZoomRes Cys 16, step = 50 wait 100 ZoomRes all VMD Tcl/Tk command:\nset crystal [atomselect top \u0026quot;all\u0026quot;] $crystal moveby {10 0 0} $crystal move [transaxis x 40 deg] set sel [atomselect top \u0026quot;hydrophobic and alpha\u0026quot;] $sel get resname $sel get resid $sel get {resname resid} $sel get {x y z} graphics top cylinder {15 0 0} {15 0 10} radius 10 resolution 60 filled no graphics top cylinder {0 0 0} {-15 0 10} radius 5 resolution 60 filled yes graphics top cone {40 0 0} {40 0 10} radius 10 resolution 60 graphics top sphere {65 0 5} radius 10 resolution 80 graphics top triangle {80 0 0} {85 0 10} {90 0 0} graphics top text {40 0 20} \u0026quot;my drawing objects\u0026quot; PyMOL command:\nselect active, (resi 14-20,38) and chain A zoom active hide all show stick, active select active_water, ( (resi 38 and name ND2 and chain A) around 3.5) and (resn HOH) show spheres, active_water alter active_water, vdw=0.5 rebuild isomesh mesh1, 2fofc.map, 1.0, (resi 14-20,38 and chain A), carve=1.6 isomesh mesh1, 2fofc.map, 1.0, active, carve=1.6 color grey, mesh1 bg_color white As you can see, DSL is a programming language that is\u0026hellip; well, as it says, dealing with a specific domain. For example, the DSL used by YASARA, PyMOL, and VMD is for molecular file I/O processing, molecule selection, manipulation, and visualisation. In other words, those DSLs are specifically targeting molecular information, model, and visualisation domain.\nSome other well-known DSLs include R, Matlab, SQL, HTML\u0026amp;CSS, and spreadsheet formulas, which correspond to statistics, modeling, database, webpage, and spreadsheet domain.\nBut then, what are the differences between General Programming Languages (GPLs) like Java, C++, Fortran, or Python compared to DSL? Also, wouldn\u0026rsquo;t it be too much hassle for us to learn a programming language to solve a specific problem? Compared to GPLs, DSL is far simpler because DSL uses far more limited vocabulary, grammar, and syntax. Using vocabulary specific to a particular domain alone is already lowering the learning barrier significantly since the domain expert (e.g., computational chemist) is familiar with the DSL commands (verb or noun). And thus, the domain expert could correlate most of the commands with their mental model. For example, even when a computational chemist never used VMD before, (s)he will immediately understand what protein and within 4.5 of resname TPF means.\nWell, of course, since the commands and operations in DSL are not as rich as GPL, wouldn\u0026rsquo;t that make DSL less expressive than GPL? Ideally, the DSL should be expressive enough to allow the domain expert to solve every problem that (s)he faces in a specific domain. Therefore DSL should be as simple as possible yet still allow the domain expert to express the solution to their problem.\nVoelter, in his book DSL Engineering (2013), explains that one should attempt to make DSL as close as possible to its target domain (Figure 1). Also, ideally, the DSL should not be under-approximated, in which case it lacks the capability to express the solution in its target domain. On the other hand, it should not over-approximate where it is way too complicated (or overengineered) so that it is capable of doing the operation or implementation that is not required, which is somewhat similar to violating the YAGNI principle (Figure 2).\nFigure 1. Program Domain and Program Language are subsets of Program sets. DSL (program language) is supposed to overlap as much as possible with its target domain.\nFigure 2. PL 1 is Program Language 1 (DSL 1) and PL 2 is Program Language 2 (DSL 2), PL 1 is under-approximated while PL 2 is over-approximated.\nOverall, when DSL is carefully designed and implemented, it can be a powerful yet concise tool for domain experts to express the solution in the target domain.\nI believe that is enough explanation for DSL. I choose to explain DSL first so that I can explain to you why we need DSL for molecular interaction analysis in the next section.\nIs it really necessary to bring DSL to molecular interaction analysis? As someone who has been dealing with interaction fingerprinting for more than a decade, I am fully aware of the severe limitation of the solution that can be offered by an Interaction Fingerprinting (IFP) tool.\nFor example, the IFP tools are usually running according to the choices specified in the configuration file. In other cases, it uses a simple form or wizard using GUI or web interface. This way, the path that can be taken is very limited because:\n The developers expect the users to take only the happy path so that nothing can go wrong. Many things have been taken care of under the hood so that the users do not have to deal with so many technical-level details. Integrating a new solution into the existing software is difficult. For example, in electrostatic interaction analysis, to modify the atom typing algorithm for positively charged atoms, you have to change the code or SMARTS pattern that identifies the positively charged atoms. One way to overcome this is by providing a plugin system that allows the user to integrate a new solution into the IFP tool. FingeRNAt uses this approach to allow user-defined interaction.  On the other end of the spectrum, there is ProLIF, a Python library for molecular interaction analysis. This means that rather than using a command line + configuration file or graphical interface, it uses a series of commands that will be executed. The benefit of this approach is the expressiveness of this tool, as it gives the user more control starting from which molecular fragment to analyze, the result from presentation for reporting or further analysis, adding or changing the geometry rule for a particular interaction, and of course defining new scoring function for interaction similarity.\nThe only caveat is, first of all, you should be able to use Python language to a certain degree of mastery. Second, if you are doing an edge case study, there is a chance you have to extend the deeper level implementation in ProLIF which IMO is not trivial.\nAlso, although in theory, it is possible to express every program domain using Python, ProLIF, and RDKit (as one of ProLIF dependencies), in practice trying to implement a program domain that is not implemented by the ProLIF library will not be easy. For example, we can observe in the ProLIF community that few demanded ProLIF be able to present the interaction result at the atomic level. And to overcome this limitation, the ProLIF developer has to change the core source code so that the interactions are not only registered at the residue level but also at the atomic level.\nWhichever the tools that computational chemist use, it seems like there is no end to the creativity and expressiveness in interaction fingerprinting. The feature demands for IFP tools are incredible, starting from support for various file formats, geometric criteria for each interaction, atom typing, molecular interaction variety (nonpolar, electrostatic, pi, etc.), similarity scoring and weighting algorithm, molecule preparation, and presentation of the analysis result. The vastness of the workflow and use case for this methodology could overwhelm the developer of the IFP tool.\nNow that we have seen the good and the bad of each end of the spectrum and a glimpse of the complexity of molecular interaction analysis, I suppose it is time for me to explain how a Domain Specific Language could be a better alternative.\nFirst, let\u0026rsquo;s create an imaginary language to analyse the internal nonpolar interaction inside the protein.\nopen 1znm.pdb select \u0026quot;protein\u0026quot; as prot measure nonpolar in prot present nonpolar at atomic level Looks very neat isn\u0026rsquo;t it? Next, let us specify our atom typing for nonpolar atoms, and then store the result in zinc_finger_nonpolar.txt file.\nopen 1znm.pdb select \u0026quot;protein\u0026quot; as prot specify nonpolar atom with smarts_pattern \u0026quot;[$([CH3X4,CH2X3,CH1X2,F,Cl,Br,I])\u0026amp;!$(**[CH3X4,CH2X3,CH1X2,F,Cl,Br,I])]\u0026quot; measure nonpolar in prot present nonpolar at atomic level into zinc_finger_nonpolar.txt Last, another imaginary language to analyse four different interactions between two molecules:\nopen 6ma7.pdb select \u0026quot;protein\u0026quot; as prot select \u0026quot;resname TPF\u0026quot; as fluconazole measure nonpolar, hbond, electrostatic, pi between prot and fluconazole present all at bitstring level into cyp3a4_bitstring.txt They may seem so simple at first, but what is so incredible and beautiful about this language is how clear and concise yet at the same time, it can incorporate each detail step by step.\nAnd needlessly to say, it is still very simple and may look like a toy. To make it far more powerful we will have to decide the (molecular interaction) domain we are trying to cover. Then we can decide how much control or implementation we could bestow upon our dear user. Something that I will present in the next post.\nRevision Note:\n Oct 25, 2023: Add link to ProLIF feature request  ","permalink":"https://radifar.github.io/posts/lets-create-domain-specific-language-molecular-interaction-analysis/","summary":"What is a Domain-Specific Language? It is more common than you think. Few of us – computational chemists – have heard the term Domain-Specific Language (DSL for short), even though this is somewhat ubiquitous in our workflow, especially when dealing with molecule visualisation. Don\u0026rsquo;t you believe me? Check out the command you type on VMD, PyMOL, YASARA, or Chimera.\nYASARA command:\nLoadPDB 1crn, download=yes AutoPosOriObj 1, x = 1, y = 10, z = 0, alpha = 0, beta = 0, gamma = 0 ColorRes cys, green ShowRes cys BallStickRes cys AutoRotateObj 1, Y = 1 wait 180 AutoRotateObj 1, Y = 0 ZoomRes Cys 16, step = 50 wait 100 ZoomRes all VMD Tcl/Tk command:","title":"Lets Create A Domain-Specific Language for Molecular Interaction Analysis!"},{"content":"Prerequisite  Basic command prompt Basic Python (variable type, collection, loop, decision, and functions) Python virtual environment (conda/mamba) Jupyter notebook/lab  Create new environment So first as always, start with creating new environment (preferably mamba). If you have never used mamba before and have some experience with conda then great, you can simply change every conda command with mamba and vice versa.\nCreate new environment for this series using this command:\nmamba create -n learn-open-babel python=3.9 openbabel pandas jupyterlab rich Brief explanation for the command above:\n create -n learn-open-babel means create new environment with the name learn-open-babel. python=3.9 means we choose Python version 3.9.x for this environment. pandas is the data analysis tool that we will be using throughout the series. jupyterlab kind of like jupyter notebook, but I prefer this one because it is easier to deal with multiple file. rich this one is for aesthetic purpose, this package is awesome and make reading the output easier.  Next, activate our environment with:\nmamba activate learn-open-babel Test our setup environment Open Babel test First lets try and run Python by typing python and press enter, something like this should appear:\nPython 3.9.12 | packaged by conda-forge | (main, Mar 24 2022, 23:25:59) [GCC 10.3.0] on linux Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; Next, we will check if Open Babel library installed correctly, type the following command in your Python prompt:\n\u0026gt;\u0026gt;\u0026gt; import openbabel \u0026gt;\u0026gt;\u0026gt; openbabel.__version__ \u0026#39;3.1.0\u0026#39; Lets test this library a bit more…\n\u0026gt;\u0026gt;\u0026gt; from openbabel import openbabel as ob \u0026gt;\u0026gt;\u0026gt; \u0026gt;\u0026gt;\u0026gt; converter = ob.OBConversion() \u0026gt;\u0026gt;\u0026gt; converter.SetInFormat(\u0026#34;smi\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; ethanol = ob.OBMol() \u0026gt;\u0026gt;\u0026gt; converter.ReadString(ethanol, \u0026#34;OCC\u0026#34;) True \u0026gt;\u0026gt;\u0026gt; ethanol.NumAtoms() 3 \u0026gt;\u0026gt;\u0026gt; ethanol.AddHydrogens() True \u0026gt;\u0026gt;\u0026gt; ethanol.NumAtoms() 9 This is just a simple test to load the openbabel library and try to read the SMILES string of ethanol. I will explain the details in the later part of the series. If you get the same output (True, True, 3, True, 9) most likely your Open Babel installed correctly.\nNext lets do some quick test on Jupyter lab.\nJupyter lab test Now, still in the learn-open-babel environment, lets create new directory for this series. And then run Jupyterlab inside the new directory.\nmkdir open_babel_python cd open_babel_python jupyter lab Your command prompt should take you to your default browser and open the Jupyter lab for you.\n Jupyter Lab landing page   Nice. Go to the launcher tab, and click the Python icon below the Notebook header. A new untitled notebook should appear and new file untitled.ipynb should appear in the current directory. If you have some experience with Jupyter Notebook, the experience is similar, it just have a better workflow and looks in my opinion.\nIn the next part of this series we will take a look at the basic workflow of opening the molecule file with Open Babel and Python.\n","permalink":"https://radifar.github.io/posts/learn-open-babel-python-00-setup/","summary":"Prerequisite  Basic command prompt Basic Python (variable type, collection, loop, decision, and functions) Python virtual environment (conda/mamba) Jupyter notebook/lab  Create new environment So first as always, start with creating new environment (preferably mamba). If you have never used mamba before and have some experience with conda then great, you can simply change every conda command with mamba and vice versa.\nCreate new environment for this series using this command:","title":"Learn Open Babel in Python - 00 Setup"},{"content":"There are many ways to improve structure-based virtual screening, from something as simple as screening the ligand based on the physico-chemical properties (MW, number of H-donor, number of aromatic rings, pKa, etc.), using consensus docking, or even post-analysis using FEP-based method.\nOne of the simplest and yet fruitful approach to enhance the virtual screening workflow is using interaction fingerprinting. It has been known for long time that certain interaction from certain residue holds more significance than others. And this is especially true when it comes to receptor, where some residue holds the key for agonism while some others for antagonism (or reverse agonism). This key idea, in turn can be used to analyze the interaction pattern (hence, interaction fingerprinting) to figure out if the ligand is a potential agonist, antagonist, or just a dud.\nWhen I was starting my research (in 2011) on interaction fingerprinting, I found that the earliest use of interaction fingerprinting is in 2004 by Deng et al. under the term Structural Interaction Fingerprinting (SIFt). I do not know if there is any earlier use than that, but if you do please comment below. Back then it was still difficult to find a software that could do interaction fingerprinting. The only (standalone) software I could find was Fingerprintlib by Marcou and Rognan (2007). It is free to use, and you can read the source code too. Now, unfortunately it uses OpenEye Chem library which isn\u0026rsquo;t free back then. Back then, I wanted to use a free (both gratis and open source) tool for interaction fingerprinting, and I thought to myself maybe I could build one with Python programming language!\nFirst, to see if this idea could work I tried to find the alternative(s) for OpenEye Chem. That\u0026rsquo;s when I found out that it turns out OEChem and Open Babel is actually derive from the same code! What a coincidence! And then I\u0026rsquo;m starting by analyzing the algorithm behind Fingerprintlib which is written in C++, alternating between the Fingerprintlib publication paper and reading the code I begin to understand how it works behind the scene. And luckily, the OEChem API and Open Babel API is very similar.\nThe next step, and I think the most difficult part is when I have to learn the Open Babel library. As this is my first time doing a professional programming task, Open Babel is very complicated! There were not many examples on how to use Open Babel in Python library, most of the examples that I found is only from the documentation and O\u0026rsquo;Boyle blog. Therefore I spent 1 month of my time to learn Open Babel API by printing out the Open Babel module I am most likely used: OBMol, OBConversion, OBResidue, OBAtom, etc. then going through lots of trial and error to understand the objects, methods, input, and output from those modules.\nBy the new year eve of 2012 I\u0026rsquo;ve got most of the thing I need to use Open Babel in my library, then I\u0026rsquo;m having my first meeting in a cafe with my colleague, Enade. I can\u0026rsquo;t remember clearly, but for some reason I was riding my bicycle from my home to the cafe, which is about 9 km away as fast as I could that I arrived at the cafe in just 30 minutes LOL. If I remember correctly, the meeting itself was sudden, maybe because I shared some of my \u0026lsquo;fantastic\u0026rsquo; progress to him about using Open Babel \u0026amp; Python to recognize protein structure. And he would like to immediately collaborate with me to produce our own interaction fingerprinting tool.\nOne thing to note is that I was doing this purely out of passion, I didn\u0026rsquo;t receive any compensation apart from having my name came first in our PyPLIF paper. I wasn\u0026rsquo;t doing this to get money either. I really love to share my code to the open source community as I have already receive a lot from them. I also think that it is wonderful to share your work so that other people in the other side of the earth could use it for their work.\nOne month later, by the end of January 2012. PyPLIF alpha is ready! Oh right, I haven\u0026rsquo;t mentioned two important thing. First, PyPLIF can only read/analyze docking results from PLANTS, and second why named with PyPLIF? Back then we have two freely available molecular docking tools, AutoDock Vina and PLANTS. Back then me and Enade didn\u0026rsquo;t use Vina because we didn\u0026rsquo;t like the fact that we have to rely on GUI for every molecule preparation prior to docking (which is turns out to be not true). Second we would like to replicate the study from de Graaf (2011) on SBVS for fragment-like ligands of HRH1, which is using interaction fingerprinting and PLANTS as the docking tool. Since that study is a great success, surely there is a huge potential in using PLANTS and writing an Interaction Fingerprinting tool for PLANTS docking result.\nWhat about PyPLIF? Well, there is a tradition in Python package development where the name of the package begin with Py (which obviously stand for Python). And since the software can be used to analyze protein-ligand interaction hence the name, PyPLIF (Python-based Protein Ligand Interaction Fingerprinting).\nTo check if PyPLIF working as intended we decided to use the simple interaction fingerprint in figure 2 from de Graaf (2011) study. After some comparison and visual inspection we managed to replicate the interaction fingerprint from that. The next step is comparing interaction fingerprint from the whole SBVS campaign. Thanks to the authors courtesy we managed to obtain the interaction fingerprint and start comparing the whole fingerprint. And\u0026hellip; as expected there is a slight differences, which is makes sense because their interaction fingerprinting tool uses OEChem library and our tool uses Open Babel library which in some occasion would recognize molecule/atom in a different way.\nThe next step is of course to publish our work. We didn\u0026rsquo;t aim high back then, therefore we decided to publish PyPLIF in Bioinformation (IF: around 1 when we about to submit our work). And voila! It was accepted as is! No revision or whatsoever. Well, seems like we aim too low. But whatever, I guess that\u0026rsquo;s all for now. The next thing I would like to share is about PyPLIF weaknesses and lack of features. But that will be on the next part.\nHistory 1.0 article ready, without link, or picture. (2020-09-12)\n","permalink":"https://radifar.github.io/posts/2020-09-12-the-story-behind-pyplif-hippos-part-1/","summary":"There are many ways to improve structure-based virtual screening, from something as simple as screening the ligand based on the physico-chemical properties (MW, number of H-donor, number of aromatic rings, pKa, etc.), using consensus docking, or even post-analysis using FEP-based method.\nOne of the simplest and yet fruitful approach to enhance the virtual screening workflow is using interaction fingerprinting. It has been known for long time that certain interaction from certain residue holds more significance than others.","title":"The Story Behind PyPLIF HIPPOS (Part 1)"},{"content":"So yesterday I spent at least 3 hours to deal with Python package development in Conda environment. So I wrote this post as a self-reminder, since the steps are somewhat long. And also for those of you who is facing the same problem as I do.\nWhy do I need to use pip when I can use Conda to install Open Babel If you\u0026rsquo;re an experienced Python package developer you should have known the following trick:\npip install -e .\nFor those of you who do not know, this command is for installing your package in editable mode, which means every change you made to your package will immediately reflected to your environment without having to reinstall your package. Amazing huh?\nThis trick is very useful when I was developing my package and I was satisfied, until\u0026hellip; I made the change to setup.py in order to stage my package to conda-forge so my package can be installed using conda. And then I just figured it out when there is some minor bug in my package recently, and debugging would be much easier if I could see the result every time I patch the code.\nBut alas, for some reason pip install -e . just doesn\u0026rsquo;t work anymore. Well, the first reason is one of my package dependency (Open Babel) can only be installed with Conda or package manager (apt, yum, etc.), and since I added package dependency to setup.py pip will try to install Open Babel which doesn\u0026rsquo;t work. The second reason was, when I run pip install -e . --no-deps with the assumption that my package will use Open Babel from Conda environment, but that doesn\u0026rsquo;t work because package installed with pip in editable mode can not recognize the conda environment.\nMy first approach is by googling the workaround for pip editable mode in Conda environment, but the answers I found were too complicated and require me to create new Conda environment everytime I want to use the development environment via pip install -e . . And then the other alternative is using conda develop command, which is an alternative for pip install -e .. But too bad that conda develop has been abandoned and can not serve its purpose since what I really need is the entrypoint so that every time I update the code I can check my package by typing hippos or hippos-genref command.\nsetup.py come to rescue And then finally, I use my last resort. That is\u0026hellip; by installing Open Babel to my pip environment (inside my Conda environment) from the source. First of all I follow the build instruction for Open Babel. After making sure the requirement satisfied (especially SWIG for SWIG binding)\ntar -zxf openbabel-openbabel-3-1-1.tar.gz cd openbabel-openbabel-3-1-1 mkdir ob-build cd $_ cmake -DRUN_SWIG=ON -DPYTHON_BINDINGS=ON -DCMAKE_INSTALL_PREFIX=../openbabel-install .. make -j4 install And then using the Open Babel pip source file to install Open Babel Python binding to my pip environment with the following command:\ntar -zxf openbabel-3.1.1.1.tar.gz cd openbabel-3.1.1.1 python setup.py build_ext -I ~/radifar.pro/openbabel/openbabel-openbabel-3-1-1/openbabel-install/include/openbabel3/ -L ~/radifar.pro/openbabel/openbabel-openbabel-3-1-1/openbabel-install/lib/ python setup.py install Note here that the -I and -L option is to specify the Open Babel Include and Library directory where you install your Open Babel.\nThen check if Open Babel is installed in pip environment inside Conda environment using conda env export:\n... - xorg-xproto=7.0.31=h14c3975_1007 - xz=5.2.5=h516909a_1 - zlib=1.2.11=h516909a_1006 - pip: - attrs==19.3.0 - coverage==5.2.1 - importlib-metadata==1.7.0 - more-itertools==8.4.0 - openbabel==3.1.0 - packaging==20.4 - pluggy==0.13.1 - py==1.9.0 - pyparsing==2.4.7 - pytest==5.4.3 - pytest-cov==2.10.0 - six==1.15.0 - wcwidth==0.2.5 - zipp==3.1.0 Then check if Open Babel can be imported from my Conda environment:\nPython 3.7.8 | packaged by conda-forge | (default, Jul 23 2020, 03:54:19) [GCC 7.5.0] on linux Type \u0026quot;help\u0026quot;, \u0026quot;copyright\u0026quot;, \u0026quot;credits\u0026quot; or \u0026quot;license\u0026quot; for more information. \u0026gt;\u0026gt;\u0026gt; from openbabel import openbabel \u0026gt;\u0026gt;\u0026gt; Great! Now Open Babel is running perfectly under pip in Conda environment. OK, so that\u0026rsquo;s all folks. Hope this post can help solve your problem. And if you have any question feel free to ask in the comment section below.\n","permalink":"https://radifar.github.io/posts/2020-08-26-editable-pip-in-conda-env/","summary":"So yesterday I spent at least 3 hours to deal with Python package development in Conda environment. So I wrote this post as a self-reminder, since the steps are somewhat long. And also for those of you who is facing the same problem as I do.\nWhy do I need to use pip when I can use Conda to install Open Babel If you\u0026rsquo;re an experienced Python package developer you should have known the following trick:","title":"Installing Open Babel with Pip"},{"content":"Who Am I My name is Muhammad Radifar, but when you contact me just call me Radif. I am from Indonesia. Currently I am a\n Independent Researcher @PICompS Freelancer Research Assistant Computational Chemist, experienced with  Molecular Dynamics  NAMD GROMACS   Homology Modeling  Modeller   Molecular Docking  AutoDock Vina PLANTS   Molecule Visualization  VMD     Software Engineer (Python), experienced with  Open Babel Jupyter Notebook Sphinx documentation   Full Stack Developer  Front End: Vue Back End: Django API: GraphQL    Would Like To Know Me Better? See My Projects link above. Or click on my Github, Twitter, or Linkedin links below.\n","permalink":"https://radifar.github.io/about/","summary":"Who Am I My name is Muhammad Radifar, but when you contact me just call me Radif. I am from Indonesia. Currently I am a\n Independent Researcher @PICompS Freelancer Research Assistant Computational Chemist, experienced with  Molecular Dynamics  NAMD GROMACS   Homology Modeling  Modeller   Molecular Docking  AutoDock Vina PLANTS   Molecule Visualization  VMD     Software Engineer (Python), experienced with  Open Babel Jupyter Notebook Sphinx documentation   Full Stack Developer  Front End: Vue Back End: Django API: GraphQL    Would Like To Know Me Better?","title":"About Me"}]